/**
 * @param {string} base64
 * @return {string}
 */
function base64ToBase64url(base64){
	return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=*$/g, "");
}
/**
 * @param {string} base64url
 * @return {string}
 */
function base64urlToBase64(base64url){
	/** @type {string} */
  var base64 = base64url.replace(/-/g, "+").replace(/_/g, "/");
	/** @type {number} */
	var padding = base64.length % 4;
	if (padding > 0) {
		base64 += "====".slice(padding);
	}
	return base64;
}
/**
 * @param {string} raw
 * @return {string}
 */
function rawToBase64url(raw){
	// return base64ToBase64url(forge.util.encode64(raw));
	return base64ToBase64url(window.btoa(raw));
}
/**
 * @param {string} base64url
 * @return {string}
 */
function base64urlToRaw(base64url){
	// return forge.util.decode64(base64urlToBase64(base64url));
	return window.atob(base64urlToBase64(base64url));
}
/**
 * @param {Uint8Array} uarr
 * @return {string}
 */
function u8arrToRaw(uarr){
	/** @type {Array<string>} */
	var arr = [];
	/** @type {number} */
	var i = 0;
	while(i<uarr.length){
		arr.push(String.fromCharCode(uarr[i]));
		i++;
	}
	return arr.join("");
}
/**
 * @param {string} raw
 * @return {!Uint8Array}
 */
function rawToU8arr(raw){
	/** @type {!Uint8Array} */
	var arr = new Uint8Array(raw.length);
	for(var i=0; i<raw.length; i++){
		arr[i] = raw.charCodeAt(i);
	}
	return arr;
}
/**
 * @param {string} _pwd
 * @param {string} _salt
 * @param {number} _keySize
 * @param {number} _ivSize
 * @return {AesSecrets}
 */
function computeEvpKDF(_pwd, _salt, _keySize, _ivSize){
	/** @type {forge.md.digest} */
	var md = forge.md.md5.create();
	/** @type {number} */
	var totalSize = _keySize + _ivSize;
	/** @type {forge.util.ByteStringBuffer} */
	var keydat = new forge.util.ByteStringBuffer();
	/** @type {string} */
	var block = "";
	while(keydat.length() < totalSize){
		md.start();
		if(block){
			md.update(block);
		}
		md.update(_pwd);
		md.update(_salt);
		block = md.digest().getBytes();
		keydat.putBytes(block);
	}
	// truncate to the correct keydat length
	keydat.truncate(keydat.length() - totalSize);
	return {
		key: keydat.getBytes(_keySize),
		iv: keydat.getBytes(),
	};
}

/**
 * Create the crypt config
 *
 * @param {string} _pwd
 * @param {string=} _salt
 * @return {AesSecrets}
 */
function zbCreateCfg(_pwd, _salt){
	/** @type {string|null} */
	var salt = null;
	if(_salt){
		salt = _salt;
	}else{
		/** @type {forge.md.digest} */
		var md = forge.md.md5.create();
		md.update(_pwd);
		salt = md.digest().getBytes();
	}

	return computeEvpKDF(_pwd, salt, 256/8, 128/8);
}

// ------ String cryption of webCrypto version. ------ //
/**
 * Do data cryption.
 *
 * @param {boolean} _encFlg
 * @param {!Uint8Array} _dat
 * @param {string|AesSecrets} _cfg
 * @return {!Promise<!ArrayBuffer>}
 */
async function zbDataCryptoW(_encFlg, _dat, _cfg){
	/** @type {string|AesSecrets} */
	var cfg = _cfg;
	if(typeof _cfg == "string"){
		cfg = zbCreateCfg(_cfg);
	}
	if(!(cfg && cfg.iv && cfg.key)){
		throw new Error("Need iv and key. They can be generated by zbCreateCfg from password and salt.");
	}

	/** @type {webCrypto.AesCbcParams} */
	var aes = {
		name: "AES-CBC",
		iv: rawToU8arr(cfg.iv),
	};
	/** @type {!CryptoKey} */
	var key = await window.crypto.subtle.importKey("raw", rawToU8arr(cfg.key), aes.name, false, [_encFlg ? "encrypt" : "decrypt"]);
	/** @type {ArrayBuffer} */
	var ret = null;
	if(_encFlg){
		ret = await window.crypto.subtle.encrypt(aes, key, _dat);
	}else{
		ret = await window.crypto.subtle.decrypt(aes, key, _dat);
	}
	return ret;
}
/**
 * @param {string} _str
 * @param {string|AesSecrets} _cfg
 * @return {!Promise<string>}
 */
async function zbEncryptStringW(_str, _cfg){
	/** @type {!Uint8Array} */
	var datIn = new TextEncoder().encode(_str);
	/** @type {!ArrayBuffer} */
	var datOut = await zbDataCryptoW(true, datIn, _cfg);
	return base64ToBase64url(window.btoa(u8arrToRaw(new Uint8Array(datOut))));
}
/**
 * @param {string} _str
 * @param {string|AesSecrets} _cfg
 * @return {!Promise<string>}
 */
async function zbDecryptStringW(_str, _cfg){
	/** @type {!Uint8Array} */
	var datIn = rawToU8arr(window.atob(base64urlToBase64(_str)));
	/** @type {!ArrayBuffer} */
	var datOut = await zbDataCryptoW(false, datIn, _cfg);
	return new TextDecoder().decode(datOut);
}

// ------ String cryption of node-forge version. ------ //
/**
 * Do data cryption.
 *
 * @param {boolean} _encFlg
 * @param {string} _dat
 * @param {string|AesSecrets} _cfg
 * @return {string} // raw data
 */
function zbDataCrypto(_encFlg, _dat, _cfg){
	/** @type {string|AesSecrets} */
	var cfg = _cfg;
	if(typeof _cfg == "string"){
		cfg = zbCreateCfg(_cfg);
	}
	if(!(cfg && cfg.iv && cfg.key)){
		throw new Error("Need iv and key. They can be generated by computeEvpKDF from password and salt.");
	}

	/** @type {forge.util.ByteStringBuffer} */
	var key2 = forge.util.createBuffer(cfg.key);
	/** @type {forge.cipher.BlockCipher} */
	var cipher = null;
	if(_encFlg){
		cipher = forge.cipher.createCipher("AES-CBC", key2);
	}else{
		cipher = forge.cipher.createDecipher("AES-CBC", key2);
	}
	cipher.start({iv: cfg.iv});
	cipher.update(forge.util.createBuffer(_dat));
	cipher.finish();
	return cipher.output.getBytes();
}
/**
 * @param {string} _str
 * @param {string|AesSecrets} _cfg
 * @return {string}
 */
function zbEncryptString(_str, _cfg){
	/** @type {string} */
	var datIn = forge.util.encodeUtf8(_str);
	/** @type {string} */
	var datOut = zbDataCrypto(true, datIn, _cfg);
	return rawToBase64url(datOut);
}
/**
 * @param {string} _str
 * @param {string|AesSecrets} _cfg
 * @return {string}
 */
function zbDecryptString(_str, _cfg){
	/** @type {string} */
	var datIn = base64urlToRaw(_str);
	/** @type {string} */
	var datOut = zbDataCrypto(false, datIn, _cfg);
	return forge.util.decodeUtf8(datOut);
}

// ------ Define Classes ------ //
/**
 * @constructor
 * @implements {ZBWriter}
 * @param {ZBWriterOption=} opt
 *
 * opt = {
 *   _downEle: HTMLLinkElement,   // optional
 * }
 */
function ZBlobWriter(opt){
	/** @private @type {number} */
	this.fsize = 0;
	/** @private @type {Array<!ArrayBuffer|!Uint8Array>} */
	this.arrbuf = null;
	/** @private @type {HTMLLinkElement} */
	this.downEle = null;
	if(opt && opt._downEle){
		this.downEle = opt._downEle;
	}

	// --- Implement interface methods Start --- //
	/**
	 * @public
	 * @param {number} fsize
	 * @return {!Promise<void>}
	 */
	this.prepare = async function(fsize){
		this.fsize = fsize;
		if(this.downEle && this.downEle.href != "#"){
			window.URL.revokeObjectURL(this.downEle.href);
		}
	};
	/**
	 * @public
	 * @param {ArrayBuffer|Uint8Array} buf
	 * @return {!Promise<void>}
	 */
	this.write = async function(buf){
		if(!this.arrbuf){
			this.arrbuf = new Array();
		}
		this.arrbuf.push(buf);
		buf = null;
	};
	/**
	 * @public
	 * @return {!Promise<void>}
	 */
	this.cancel = async function(){};
	// --- Implement interface methods End --- //

	/**
	 * @public
	 * @return {Uint8Array}
	 */
	this.getBuffer = function(){
		if(this.arrbuf && this.arrbuf.length > 0){
			if(this.arrbuf[0] instanceof ArrayBuffer || this.arrbuf[0] instanceof Uint8Array){
				/** @type {number} */
				var sumLength = 0;
				for(var i = 0; i < this.arrbuf.length; i++){
					sumLength += this.arrbuf[i].byteLength;
				}
				/** @type {Uint8Array} */
				var whole = new Uint8Array(sumLength);
				/** @type {number} */
				var pos = 0;
				for(var i = 0; i < this.arrbuf.length; ++i){
					/** @type {!Uint8Array} @suppress {checkTypes} */
					var dat = this.arrbuf[i];
					if(dat instanceof ArrayBuffer){
						dat = new Uint8Array(dat);
					}
					whole.set(dat, pos);
					pos += dat.byteLength;
				}
				return whole;
			}
		}
		return null;
	};
	/**
	 * @public
	 * @return {!Blob}
	 */
	this.getBufferBlob = function(){
		/** @type {Uint8Array} */
		var buf = this.getBuffer();
		if(!(buf instanceof Uint8Array)){
			buf = new Uint8Array(buf);
		}
		return new Blob([buf], { "type" : "application/octet-binary" });
	};
	/**
	 * @public
	 * @param {string} fnm
	 */
	this.download = function(fnm){
		/** @type {!Blob} */
		var blob = this.getBufferBlob();
		downloadBlob(blob, fnm, this.downEle);
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.getTotalSize = function(){
		return this.fsize;
	};
}

/**
 * @constructor
 * @implements {ZBReader}
 * @param {ZBReaderOption} _opt
 *
 * _opt = {
 *   _blob: Blob,    // required
 *   _bufSize: 999,  // optional
 * }
 */
function ZBlobReader(_opt){
	/** @private @type {Blob} */
	this.blob = null;
	if(_opt._blob){
		if(_opt._blob instanceof Blob){
			this.blob = _opt._blob;
		}else{
			throw new Error("blob is not a Blob.");
		}
	}else{
		throw new Error("blob must be specified.");
	}

	/**
	 * buffer size per read
	 *
	 * @private
	 * @type {number}
	 */
	this.bufSize = 1600;
	if(_opt._bufSize){
		this.bufSize = _opt._bufSize;
	}
	/** @private @type {number} */
	this.pos = 0;
	/** @private @type {FileReader} */
	this.reader = null;

	// --- Public methods Start --- //
	// --- Implement interface methods Start --- //
	/**
	 * @public
	 * @param {number=} offset
	 * @return {!Promise<void>}
	 */
	this.prepare = async function(offset){
		if(offset){
			if(offset >= this.getSize()){
				throw new Error("offset can not be bigger than input size.");
			}else{
				this.pos = offset;
			}
		}else{
			this.pos = 0;
		}

		this.reader = new FileReader();
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.getBufSize = function(){
		return this.bufSize;
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.getPos = function(){
		return this.pos;
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.getSize = function(){
		return this.blob.size;
	};
	/**
	 * @public
	 * @return {boolean}
	 */
	this.isEnd = function(){
		return this.pos >= this.getSize();
	};
	/**
	 * @public
	 * @param {number=} size
	 * @return {!Promise<ArrayBuffer>}
	 */
	this.read = function(size){
		return new Promise(function(resolve, reject){
			if(this.reader.readyState == 1){
				return;
			}
			this.reader.onload = function(a_evt){
				/** @type {ArrayBuffer} */
				var a_dat = a_evt.target.result;
				resolve(a_dat);
			}.bind(this);
			/** @type {number} */
			var pos1 = this.pos;
			if(size){
				this.pos += size;
			}else{
				this.pos += this.bufSize;
			}
			this.reader.readAsArrayBuffer(this.blob.slice(pos1, this.pos));
		}.bind(this));
	};
	/**
	 * @public
	 */
	this.dispose = function(){
		this.reader = null;
		this.blob = null;
	};
	// --- Implement interface methods End --- //
}

/**
 * @constructor
 * @param {ZbCryptoReaderOption} _info
 *
 * (required)_info = {
 *   (optional)_decrypt: true,
 *   (required)_keycfg: "aaabbb", // keycfg may be an object as the config of crypto or a string as the password.
 *   (required)_reader: Reader,
 * };
 */
function ZbCryptoReader(_info){
	/**
	 * block size of aes is 128 bits = 16 bytes
	 *
	 * @private @const @type {number}
	 */
	this.BLOCK_SIZE = 16;

	/** @private @type {boolean} */
	this.encrypt = true;
	/** @private @type {ZBReader} */
	this.reader = _info._reader;
	/** @private @type {string} */
	this.key = "";
	/** @private @type {string} */
	this.iv = "";
	/** @private @type {forge.cipher.BlockCipher} */
	this.cryptor = null;
	/** @private @type {string} */
	this.remain = "";
	/** @private @type {number} */
	this.nextPos = 0;
	/** @private @type {number} */
	this.wholeSize = 0;
	/** @private @type {number} */
	this.locked = 0; //0 not locked, 1 locked, 2 will dispose
	/** @private @type {Array<function(boolean):void>} */
	this.waiters = [];

	if(_info._decrypt){
		this.encrypt = false;
	}
	if(!this.reader){
		throw new Error("reader must be specified.");
	}

	if(_info._keycfg){
		/** @type {AesSecrets} */
		var derivedParams = (typeof _info._keycfg == "string") ? zbCreateCfg(_info._keycfg) : _info._keycfg;
		this.key = derivedParams.key;
		this.iv = derivedParams.iv;
	}else{
		throw new Error("keycfg must be specified.");
	}

	/**
	 * @public
	 * @param {boolean=} dispose
	 * @return {!Promise<boolean>}
	 */
	this.lock = function(dispose){
		return new Promise(function(resolve, reject){
			switch(this.locked){
			case 1:
				if(dispose){
					this.locked = 2;
				}
				this.waiters.push(resolve);
				break;
			case 2:
				resolve(false);
				break;
			default:
				this.locked = dispose ? 2 : 1;
				resolve(true);
				break;
			}
		}.bind(this));
	};

	/**
	 * @public
	 */
	this.unlock = function(){
		if(this.locked > 0){
			if(this.waiters.length){
				/** @type {function(boolean):void} */
				var func = this.waiters.shift();
				func(true);
			}else if(this.locked == 1){
				this.locked = 0;
			}
		}
	};

	/**
	 * @public
	 * @return {!Promise<number>}
	 *
	 * In encrypt mode, return assumed data size after encryption.
	 * In decrypt mode, return real data size after decryption.
	 */
	this.calcWholeSize = async function(){
		if(this.wholeSize){
			return this.wholeSize;
		}
		if(this.encrypt){
			this.wholeSize = Math.ceil((this.reader.getSize()+1)/this.BLOCK_SIZE)*this.BLOCK_SIZE;
			return this.wholeSize;
		}

		if(this.reader.getSize() == 0){
			await this.prepare();
		}
		/** @type {number} */
		var offset = this.reader.getSize() - this.BLOCK_SIZE;
		/** @type {string} */
		var buf = await this.read(offset);
		this.wholeSize = offset + buf.length;
		return this.wholeSize;
	};

	/**
	 * @public
	 * @param {number=} offset
	 * @return {!Promise<void>}
	 */
	this.prepare = async function(offset){
		// console.debug("do prepare");
		/** @type {number} */
		var startPos = offset || 0;
		if(offset){
			if(this.encrypt){
				throw new Error("Can NOT set offset for encryption.");
			}
			offset -= (offset % this.BLOCK_SIZE) + this.BLOCK_SIZE;
			if(offset < 0){
				offset = 0;
			}
		}
		await this.reader.prepare(offset);

		/** @type {string} */
		var iv2 = this.iv;
		if(startPos){
			// read for decrypt
			iv2 = await this._read(this.BLOCK_SIZE);
		}

		/** @type {forge.util.ByteStringBuffer} */
		var key2 = forge.util.createBuffer(this.key);
		if(this.encrypt){
			this.cryptor = forge.cipher.createCipher("AES-CBC", key2);
		}else{
			this.cryptor = forge.cipher.createDecipher("AES-CBC", key2);
		}
		this.cryptor.start({iv: iv2});

		this.nextPos = startPos;
		this.remain = "";
	};

	/**
	 * @public
	 * @param {number=} offset
	 * @param {number=} size
	 * @return {!Promise<string>}
	 */
	this.read = async function(offset, size){
		/** @type {number} */
		var size2 = size || this.reader.getBufSize();
		/** @type {string} */
		var ret = "";
		/** @type {number} */
		var startPos = offset >= 0 ? offset : this.reader.getPos();
		if(this.nextPos == startPos && this.remain){
			if(size2 <= this.remain.length){
				this.nextPos += size2;
				ret = this.remain.substring(0, size2);
				this.remain = this.remain.substring(size2);
				if(this.remain.length == 0){
					this.remain = "";
				}
				return ret;
			}else{
				ret = this.remain;
				startPos += this.remain.length;
				this.nextPos += this.remain.length;
				size2 -= this.remain.length;
			}
		}

		/** @type {number} */
		var size3 = Math.ceil(((startPos % this.BLOCK_SIZE) + size2) / this.BLOCK_SIZE) * this.BLOCK_SIZE;
		if(!this.cryptor || this.nextPos != startPos){
			await this.prepare(startPos);
			size3 += this.BLOCK_SIZE;
		}

		/** @type {string} */
		var wdat = await this._read(size3);
		this.cryptor.update(forge.util.createBuffer(wdat));
		if(this.reader.isEnd()){
			this.cryptor.finish();
		}
		/** @type {string} */
		var ret2 = this.cryptor.output.getBytes();

		if(startPos < this.reader.getPos()){
			/** @type {number} */
			var st = startPos - (this.reader.getPos() - wdat.length);
			if(st > 0){
				ret2 = ret2.substring(st);
			}
			if(ret2.length > size2){
				this.remain = ret2.substring(size2);
				ret2 = ret2.substring(0, size2);
			}
			this.nextPos += size2;
		}else{
			ret2 = "";
		}
		if(ret){
			if(ret2){
				ret = ret.concat(ret2);
			}
		}else if(ret2){
			ret = ret2;
		}
		return ret;
	};

	/**
	 * @public
	 * @return {number}
	 */
	this.getPos = function(){
		return this.reader.getPos();
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.getSize = function(){
		return this.reader.getSize();
	};
	/**
	 * @public
	 * @return {boolean}
	 */
	this.isEnd = function(){
		return this.reader.isEnd();
	};
	/**
	 * @public
	 */
	this.dispose = function(){
		this.reader.dispose();
		this.reader = null;
		this.cryptor = null;
	};
	/**
	 * @public
	 * @return {?string}
	 */
	this.getName = function(){
		return this.reader.getName();
	};

	/**
	 * @private
	 * @param {number=} size
	 * @return {!Promise<string>}
	 */
	this._read = async function(size){
		/** @type {ArrayBuffer} */
		var buf = await this.reader.read(size);
		return u8arrToRaw(new Uint8Array(buf));
	};
}

/**
 * @constructor
 * @param {ZbCryptoOption} _info
 *
 * (required)_info = {
 *   (optional)_decrypt: true,
 *   (required)_keycfg: "aaabbb", // keycfg may be an object as the config of crypto or a string as the password.
 *   (required)_reader: Reader,
 *   (required)_writer: Writer,
 * };
 */
function ZbCrypto(_info){
	/** @private @type {ZbCryptoReader} */
	this.reader = new ZbCryptoReader(_info);
	/** @private @type {ZBWriter} */
	this.writer = _info._writer;
	/** @private @type {number} */
	this.basetime = 0;
	/** @private @type {number} */
	this.basepos = 0;
	/**
	 * Size per second.
	 *
	 * @private @type {number}
	 */
	this.speed = 0;

	if(!this.writer){
		throw new Error("writer must be specified.");
	}

	/**
	 * @public
	 * @param {number=} offset
	 * @param {(function():boolean)=} stepFunc
	 * @return {!Promise<boolean>} return true if done, else return false.
	 *
	 * stepFunc: If need next step return true, else return false.
	 */
	this.start = async function(offset, stepFunc){
		/** @type {number} */
		var startPos = offset || 0;
		/** @type {number} */
		var wsize = await this.reader.calcWholeSize();
		await this.writer.prepare(wsize);
		await this.reader.prepare(offset);

		this.basetime = Date.now() + 1000; // 1 second later
		this.basepos = startPos;

		/** @type {number} */
		var sts = this.reader.isEnd() ? 2 : 0; // 0 go on, 1 cancel, 2 done
		while(sts == 0){
			/** @type {string} */
			var ret = await this.reader.read();
			if(ret){
				await this.writer.write(rawToU8arr(ret));
			}
			if(this.reader.isEnd()){
				sts = 2;
			}else if(stepFunc && !stepFunc()){
				sts = 1;
			}
			ret = "";
		}
		if(sts == 1){
			await this.writer.cancel();
		}
		this.writer = null;
		this.reader.dispose();
		this.reader = null;
		return (sts == 2);
	};
	/**
	 * @public
	 * @return {number}
	 */
	this.calSpeed = function(){
		if(Date.now() > this.basetime){
			this.speed = (this.reader.getPos() - this.basepos) * 1000 / (Date.now() - this.basetime + 1000);
			this.basetime = Date.now() + 1000;
			this.basepos = this.reader.getPos();
		}
		return this.speed;
	}
}

/**
 * @param {ZBReader} _reader
 * @param {ZBWriter} _writer
 * @param {(function():boolean)=} _stepFunc
 * @return {!Promise<boolean>}
 */
async function zbPipe(_reader, _writer, _stepFunc){
	await _reader.prepare(0);
	await _writer.prepare(_reader.getSize());
	/** @type {number} */
	var sts = 0; // 0 go on, 1 cancel, 2 done
	while(sts == 0){
		/** @type {ArrayBuffer} */
		var buf = await _reader.read();
		await _writer.write(buf);
		if(_reader.isEnd()){
			sts = 2;
		}else if(_stepFunc && !_stepFunc()){
			sts = 1;
		}
	}
	if(sts == 1){
		await _writer.cancel();
		return false;
	}else{
		return true;
	}
}
