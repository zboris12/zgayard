
function zbCreateCfg(_pwd, _salt){
	var salt = null;
	if(_salt){
		salt = _salt;
	}else{
		salt = CryptoJS.MD5(_pwd);
	}
	return CryptoJS.kdf.OpenSSL.execute(_pwd, 256/32, 128/32, salt);
}
// _dat is WordArray or string
// _cfg may be an object as the config of crypto or a string as the password.
// the config of crypto : {
//   (required)"iv": derivedParams.iv,
//   (required)"key": derivedParams.key,
//   (optional)"mode": CryptoJS.mode.CBC,
//   (optional)"padding": CryptoJS.pad.Pkcs7,
// };
// Return WordArray
function zbDataCrypto(_encFlg, _dat, _cfg){
	var cfg = _cfg;
	if(typeof _cfg == "string"){
		cfg = zbCreateCfg(_cfg);
	}
	if(!(cfg && cfg["iv"] && cfg["key"])){
		throw new Error("Need iv and key. They can be generated by CryptoJS.kdf.OpenSSL.execute from password and salt.");
	}
	var cfg2 = {
		"mode": CryptoJS.mode.CBC,
		"padding": CryptoJS.pad.Pkcs7,
	};
	Object.assign(cfg2, cfg);

	var cryptor = null;
	if(_encFlg){
		cryptor = CryptoJS.algo.AES.createEncryptor(cfg2.key, cfg2);
	}else{
		cryptor = CryptoJS.algo.AES.createDecryptor(cfg2.key, cfg2);
	}
	var ret = cryptor.process(_dat);
	ret.concat(cryptor.finalize());
	ret.clamp();
	return ret;
}
function zbEncryptString(_str, _cfg){
	var datIn = CryptoJS.enc.Utf8.parse(_str);
	var datOut = zbDataCrypto(true, datIn, _cfg);
	return datOut.toString(CryptoJS.enc.Base64url);
}
function zbDecryptString(_str, _cfg){
	var datIn = CryptoJS.enc.Base64url.parse(_str);
	var datOut = zbDataCrypto(false, datIn, _cfg);
	return datOut.toString(CryptoJS.enc.Utf8);
}

function wordArrayToBytes(wdarr){
	var bytes = new Array(wdarr.sigBytes);
	var words = wdarr.words;
	var idx = 0;
	for(var i=0; i<words.length; i++){
		var byt = words[i];
		for(var j=idx+wordArrayToBytes.WORD_SIZE-1; j>=idx; j--){
			if(j < bytes.length){
				bytes[j] = byt & 0xFF;
			}
			byt >>= 8;
		}
		idx += wordArrayToBytes.WORD_SIZE;
		if(idx >= bytes.length){
			break;
		}
	}
	return bytes;
}
// a word is 4 bytes
wordArrayToBytes.WORD_SIZE = 4;

// ------ Define Classes ------ //

// opt = {
//   "downEle": HTMLLinkElement,   // optional
// }
function ZBlobWriter(opt){
	this.fsize = 0;
	this.arrbuf = null;
	this.downEle = null;
	if(opt && opt.downEle){
		this.downEle = opt.downEle;
	}

	// --- Public methods Start --- //
	this.prepare = function(fsize, cb){
		this.fsize = fsize;
		if(this.downEle && this.downEle.href != "#"){
			window.URL.revokeObjectURL(this.downEle.href);
		}
		if(cb){
			cb();
		}
	};
	//buf: ArrayBuffer or bytes array
	this.write = function(buf, cb){
		if(Array.isArray(buf)){
			if(this.arrbuf){
				this.arrbuf = this.arrbuf.concat(buf);
			}else{
				this.arrbuf = buf.concat();
			}
		}else{
			if(!this.arrbuf){
				this.arrbuf = new Array();
			}
			this.arrbuf.push(buf);
		}
		if(cb){
			cb();
		}
	};
	// cb: function(a_err, a_result){} // a_result: true
	this.cancel = function(cb){
		if(cb){
			cb(false, true);
		}
	};
	this.getBuffer = function(){
		if(this.arrbuf && this.arrbuf.length > 0){
			if(this.arrbuf[0] instanceof ArrayBuffer || this.arrbuf[0] instanceof Uint8Array){
				var sumLength = 0;
				for(var i = 0; i < this.arrbuf.length; i++){
					sumLength += this.arrbuf[i].byteLength;
				}
				var whole = new Uint8Array(sumLength);
				var pos = 0;
				for(var i = 0; i < this.arrbuf.length; ++i){
					var dat = this.arrbuf[i];
					if(dat instanceof ArrayBuffer){
						dat = new Uint8Array(dat);
					}
					whole.set(dat, pos);
					pos += dat.byteLength;
				}
				return whole;
			}
		}
		return this.arrbuf;
	};
	this.download = function(fnm){
		var buf = this.getBuffer();
		if(!(buf instanceof Uint8Array)){
			buf = new Uint8Array(buf);
		}
		var blob = new Blob([buf], { "type" : "application/octet-binary" });
		if(window.navigator.msSaveBlob){
			window.navigator.msSaveBlob(blob, fnm);
		}else if(this.downEle){
			this.downEle.download = fnm;
			this.downEle.href = window.URL.createObjectURL(blob);
			this.downEle.click();
		}else{
			throw new Error("Element for download is not specified.");
		}
	};
	this.getTotalSize = function(){
		return this.fsize;
	};
	// --- Public methods End --- //
}

// _opt = {
//   "blob": Blob,    // required
//   "bufSize": 999,  // optional
// }
function ZBlobReader(_opt){
	this.blob = null;
	if(_opt.blob){
		if(_opt.blob instanceof Blob){
			this.blob = _opt.blob;
		}else{
			throw new Error("blob is not a Blob.");
		}
	}else{
		throw new Error("blob must be specified.");
	}

	// buffer size per read
	this.bufSize = 1600;
	if(_opt.bufSize){
		this.bufSize = _opt.bufSize;
	}
	this.pos = 0;
	this.reader = null;

	// --- Public methods Start --- //
	this.onread = null; // function(ArrayBuffer, event_target){}

	this.prepare = function(offset, cb){
		if(offset){
			if(offset >= this.getSize()){
				throw new Error("offset can not be bigger than input size.");
			}else{
				this.pos = offset;
			}
		}

		this.reader = new FileReader();
		this.reader.onload = function(a_evt){
			var a_dat = a_evt.target.result;
			if(this.onread){
				this.onread(a_dat, this);
			}
		}.bind(this);
		if(cb){
			cb();
		}
	};
	this.getPos = function(){
		return this.pos;
	};
	this.getSize = function(){
		return this.blob.size;
	};
	this.isEnd = function(){
		return this.pos >= this.getSize();
	};
	this.read = function(size){
		if(this.reader.readyState == 1){
			return;
		}
		var pos1 = this.pos;
		if(size){
			this.pos += size;
		}else{
			this.pos += this.bufSize;
		}
		this.reader.readAsArrayBuffer(this.blob.slice(pos1, this.pos));
	};
	// --- Public methods End --- //
}

//https://qiita.com/soebosi/items/74464d2f34d7416336eb
// (required)_info = {
//   (optional)"decrypt": true,
//   (required)"keycfg": "aaabbb", // keycfg may be an object as the config of crypto or a string as the password.
//   (required)"reader": Reader, // reader.onread will be overwritten.
//   (optional)"writer": Writer, // If omitted then run as stream mode.
// };
// (optional)_opts = {}; // options for stream.Readable
function ZbCrypto(_info, _opts){
	if(!_info.writer){
		// Stream mode is created by ZbCrypto.createStream(_info, _opts).createReadStream();
		if(this.getSuperClass && this.getSuperClass().name == "Readable"){
			this.super(_opts);
			// 1: not ready, 2: not ready but need read, 3: ready
			this.streamMode = 1;
			if(_opts && _opts["objectMode"]){
				this.objectMode = true;
			}
		}else{
			throw new Error("writer must be specified in no stream mode.");
		}
	}

	// --- Constants Start --- //
	// block size of aes is 128 bits = 16 bytes
	this.BLOCK_SIZE = 16;
	this.BLOCK_WSZ = this.BLOCK_SIZE / wordArrayToBytes.WORD_SIZE;
	// --- Constants End --- //

	// --- Public members Start --- //
	this.onstep = null;  // function(){} if need next step return true, else return false. Only valid on no stream mode.
	this.onfinal = null; // function(err, canceled){} Only valid on no stream mode.
	// --- Public members End --- //

	// --- Private members Start --- //
	this.encrypt = true;
	this.reader = null;
	this.writer = _info.writer;
	this.key = null;
	this.iv = null;
	this.startPos = 0;
	this.cryptor = null;
	this.basetime = 0;
	this.basepos = 0;
	this.speed = "-";
	// --- Private members End --- //

	if(_info.decrypt){
		this.encrypt = false;
	}
	if(_info.reader){
		this.reader = _info.reader;
	}else{
		throw new Error("reader must be specified.");
	}

	if(_info.keycfg){
		var derivedParams = null;
		if(typeof _info.keycfg == "string"){
			derivedParams = zbCreateCfg(_info.keycfg);
		}else{
			derivedParams = _info.keycfg;
		}
		this.key = derivedParams.key;
		this.iv = derivedParams.iv;
	}else{
		throw new Error("keycfg must be specified.");
	}

	// --- Public methods Start --- //
	this.start = function(offset){
		if(offset){
			if(this.encrypt){
				throw new Error("Can NOT set offset for encryption.");
			}
			this.startPos = offset;
			offset -= (offset % this.BLOCK_SIZE) + this.BLOCK_SIZE;
			if(offset < 0){
				offset = 0;
			}
		}
		this.reader.onread = this.onread.bind(this);
		this.reader.prepare(offset, function(){
			var sizeEnc = Math.ceil((this.reader.getSize()+1)/this.BLOCK_SIZE)*this.BLOCK_SIZE;
			if(this.streamMode || !this.writer){
				this.firstRead();
			}else{
				this.writer.prepare(sizeEnc, this.firstRead.bind(this));
			}
		}.bind(this));
	};
	
	this.calSpeed = function(){
		if(Date.now() > this.basetime){
			var s = (this.reader.getPos() - this.basepos) * 1000 / (Date.now() - this.basetime + 1000);
			this.speed = getSizeDisp(s) + "/s";
			this.basetime = Date.now() + 1000;
			this.basepos = this.reader.getPos();
		}
		return this.speed;
	}
	// --- Public methods End --- //

	// --- Private methods Start --- //
	// method for ReadableStream Start //
	this._read = function(size){
		if(this.streamMode == 1){
			this.streamMode = 2;
		}else if(this.streamMode == 3){
			if(this.reader.isEnd()){
				this.push(null);
			}else{
				this.reader.read(size);
			}
		}
	};
	this.push = function(chunk, encoding){
		if(this.readable){
			if(chunk && !this.objectMode){
				this.superCall("push", new Uint8Array(chunk));
			}else{
				this.superCall("push", chunk);
			}
		}
	};
	// method for ReadableStream End //

	this.firstRead = function(){
		this.basetime = Date.now() + 1000; // 1 second later
		this.basepos = this.startPos;
		if(this.startPos){
			// read for decrypt
			this.reader.read(this.BLOCK_SIZE);
		}else if(this.streamMode == 1){
			this.streamMode = 3;
		}else if(this.streamMode == 2){
			this.streamMode = 3;
			this.push(new Array());
		}else{
			// start reading
			this.reader.read();
		}
	};

	this.onread = function(arrbuf, evtgt){
		try{
			var wdat = new CryptoJS.lib.WordArray.init(arrbuf);
			// create cryptor
			if(!this.cryptor){
				var cfg = {
					iv: this.iv,
					mode: CryptoJS.mode.CBC,
					padding: CryptoJS.pad.Pkcs7
				};
				if(this.startPos){
					cfg.iv = wdat;
					wdat = null;
				}
				if(this.encrypt){
					this.cryptor = CryptoJS.algo.AES.createEncryptor(this.key, cfg);
				}else{
					this.cryptor = CryptoJS.algo.AES.createDecryptor(this.key, cfg);
				}
			}
			if(wdat){
			// process data
				var ret = wordArrayToBytes(this.cryptor.process(wdat));
				if(this.reader.isEnd()){
					ret = ret.concat(wordArrayToBytes(this.cryptor.finalize()));
				}

				if(this.startPos < this.reader.getPos()){
					var st = this.startPos - (this.reader.getPos() - arrbuf.byteLength);
					if(st > 0){
						ret = ret.slice(st);
					}
				}else{
					ret = null;
				}

				if(this.streamMode){
					this.push(ret);
				}else if(ret){
					if(this.writer){
						this.writer.write(ret, function(){
							if(this.reader.isEnd()){
								if(this.onfinal){
									this.onfinal();
								}
							}else if(this.onstep){
								if(this.onstep()){
									this.reader.read();
								}else{
									this.writer.cancel(function(a_err, a_result){
										if(this.onfinal){
											if(a_err){
												this.onfinal(a_err);
											}else{
												this.onfinal(false, a_result);
											}
										}
									}.bind(this));
								}
							}else{
								this.reader.read();
							}
						}.bind(this));
					}
				}else{
					this.reader.read();
				}
			}else if(this.streamMode){
				if(this.streamMode == 2){
					this.streamMode = 3;
					this.push(new Array());
				}else{
					this.streamMode = 3;
				}
			}else{
				this.reader.read();
			}
		}catch(err){
			if(this.streamMode){
				throw err;
			}else if(this.onfinal){
				this.onfinal(err);
			}
		}
	};
	// --- Private methods End --- //
}

function ZbStreamWrapper(_info, _opts){
	const Stream = zb_require("readable-stream");
	if(ZbCrypto.super_ !== Stream.Readable){
		zb_inherits(ZbCrypto, Stream.Readable);
	}
	this.strmopts = { "highWaterMark": 800000, };
	Object.assign(this.strmopts, _opts);
	this.info = _info;
	this.stream = null;

	// opts = {
	//   (optional)"start": 0,
	//   (optional)"end": 999, // not used
	// };
	this.createReadStream = function(opts){
		this.destroyStream();
		this.stream = new ZbCrypto(this.info, this.strmopts);
		var i = 0;
		if(opts && opts["start"]){
			i = opts["start"];
		}
		this.stream.start(i);
		return this.stream;
	};
	this.destroyStream = function(){
		if(this.stream){
			this.stream.destroy();
			this.stream = null;
		}
	};
}

function zbPipe(_reader, _writer, _stepFunc, _finalFunc){
	_reader.onread = function(a_buf, a_tgt){
		_writer.write(a_buf, function(b_dat){
			if(_reader.isEnd()){
				if(_finalFunc){
					_finalFunc();
				}
			}else if(_stepFunc){
				if(_stepFunc()){
					_reader.read();
				}
			}else{
				_reader.read();
			}
		});
	};

	_reader.prepare(0, function(){
		_writer.prepare(_reader.getSize(), function(){
			_reader.read();
		});
	});
}
